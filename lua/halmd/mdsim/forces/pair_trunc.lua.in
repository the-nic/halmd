--
-- Copyright © 2010-2012 Peter Colberg
-- Copyright © 2010-2011 Felix Höfling
--
-- This file is part of HALMD.
--
-- HALMD is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.
--

local core              = require("halmd.mdsim.core")
local neighbour         = require("halmd.mdsim.neighbour")
local device            = require("halmd.utility.device")
local module            = require("halmd.utility.module")
local profiler          = require("halmd.utility.profiler")

---
-- Truncated Pair Force
-- ====================
--
--

-- grab C++ wrappers
local pair_trunc = assert(libhalmd.mdsim.forces.pair_trunc)
local discontinuous = assert(libhalmd.mdsim.forces.trunc.discontinuous)

---
-- Construct truncated pair force.
--
-- :param table args: keyword arguments
-- :param args.particle: instance, or sequence of two instances, of :class:`halmd.mdsim.particle`
-- :param args.box: instance of :mod:`halmd.mdsim.box`
-- :param args.potential: instance of :mod:`halmd.mdsim.potentials`
-- :param args.trunc: instance of :mod:`halmd.mdsim.forces.trunc` (optional)
-- :param args.neighbour: instance of :mod:`halmd.mdsim.neighbour` (optional)
--
-- If ``trunc`` is not specified, the pair potential is :math:`C^0` continuous at the cutoff.
--
-- .. attribute:: potential
--
--    Instance of :mod:`halmd.mdsim.potentials`.
--
-- .. method:: get_force()
--
--    Returns unordered sequence with particle forces.
--
-- .. method:: get_en_pot()
--
--    Returns unordered sequence with potential energies.
--
-- .. method:: get_stress_pot()
--
--    Returns unordered sequence with potential parts of stress tensors.
--
-- .. method:: get_hypervirial()
--
--    Returns unordered sequence with hypervirials.
--
-- .. method:: connect()
--
--    Connect force to profiler.
--
--    This is the default.
--
-- .. method:: disconnect()
--
--    Disconnect force from profiler.
--
--    .. warning::
--
--       Currently this does not disconnect particle sorting, binning and neighbour lists.
--
local M = module(function(args)
    local particle = args and args.particle
    if type(particle) ~= "table" then
        particle = {particle, particle}
    end
    if #particle ~= 2 then
        error("bad argument 'particle'", 2)
    end
    local box = args.box
    if not box then
        error("bad argument 'box'", 2)
    end
    local potential = args.potential
    if not potential then
        error("bad argument 'potential'", 2)
    end
    local logger = assert(potential.logger)
    local trunc = args.trunc
    if trunc then
        -- log parameters if smoothing function was specified
        trunc:log(logger)
    else
        -- otherwise default to empty function
        trunc = discontinuous()
    end

    -- create neighbour lists with cutoff radii of potential
    local r_cut = assert(potential.r_cut)
    local neighbour = args.neighbour or neighbour({box = box, particles = particle, r_cut = r_cut})

    -- construct force module
    local self = pair_trunc(potential, particle[1], particle[2], box, neighbour, trunc, logger)

    -- attach potential instance as read-only Lua property
    self.potential = property(function(self)
        return potential
    end)

    -- sequence of signal connections
    local conn = {}
    -- profiler description
    local desc = ("computation of %s interaction"):format(potential.description)

    self.connect = function(self)
        if #conn == 0 then
            local runtime = assert(self.runtime)
            table.insert(conn, assert(profiler:on_profile(runtime.compute, desc)))
        else
            error("integrator is already connected", 2)
        end
    end

    self.disconnect = function(self)
        if #conn > 0 then
            for i = 1, #conn do
                conn[i]:disconnect()
            end
            conn = {}
        else
            error("integrator is already disconnected", 2)
        end
    end

    -- connect to core and profiler
    self:connect()

    return self
end)

return M
